diff --git a/PXE/Tests.module b/PXE/Tests.module
index e69de29..12fb44b 100644
--- a/PXE/Tests.module
+++ b/PXE/Tests.module
@@ -0,0 +1 @@
+threads
\ No newline at end of file
diff --git a/src/HAL9000/headers/cmd_basic.h b/src/HAL9000/headers/cmd_basic.h
index 635acd3..6275228 100644
--- a/src/HAL9000/headers/cmd_basic.h
+++ b/src/HAL9000/headers/cmd_basic.h
@@ -13,3 +13,4 @@ FUNC_GenericCommand CmdSetLogComponents;
 FUNC_GenericCommand CmdClearScreen;
 FUNC_GenericCommand CmdRunAllFunctionalTests;
 FUNC_GenericCommand CmdRunAllPerformanceTests;
+FUNC_GenericCommand CmdListThreads2;
diff --git a/src/HAL9000/headers/cpumu.h b/src/HAL9000/headers/cpumu.h
index e1f610c..7224f63 100644
--- a/src/HAL9000/headers/cpumu.h
+++ b/src/HAL9000/headers/cpumu.h
@@ -17,7 +17,7 @@ typedef struct _THREADING_DATA
     struct _THREAD*     CurrentThread;
     struct _THREAD*     PreviousThread;
 
-    BOOLEAN             YieldOnInterruptReturn;
+    //BOOLEAN             YieldOnInterruptReturn;
 
     QWORD               IdleTicks;
     QWORD               KernelTicks;
diff --git a/src/HAL9000/src/cmd_basic.c b/src/HAL9000/src/cmd_basic.c
index 312b097..584117a 100644
--- a/src/HAL9000/src/cmd_basic.c
+++ b/src/HAL9000/src/cmd_basic.c
@@ -153,3 +153,4 @@ void
 
     TestRunAllPerformance();
 }
+
diff --git a/src/HAL9000/src/cmd_interpreter.c b/src/HAL9000/src/cmd_interpreter.c
index d0b254f..cfa7644 100644
--- a/src/HAL9000/src/cmd_interpreter.c
+++ b/src/HAL9000/src/cmd_interpreter.c
@@ -67,7 +67,7 @@ static const COMMAND_DEFINITION COMMANDS[] =
     { "timer", "$MODE [$TIME_IN_US] [$TIMES]\n\tSee EX_TIMER_TYPE for timer types\n\t$TIME_IN_US time in uS until timer fires"
                 "\n\t$TIMES - number of times to wait for timer, valid only if periodic", CmdTestTimer, 1, 3},
 
-    { "threads", "Displays all threads", CmdListThreads, 0, 0},
+    { "threads", "Displays all threads", CmdListThreads, 0, 0},//I did run the /threads command and saw the results
     { "run", "$TEST [$NO_OF_THREADS]\n\tRuns the $TEST specified"
              "\n\t$NO_OF_THREADS the number of threads for running the test,"
              "if the number is not specified then it will run on 2 * NumberOfProcessors",
@@ -106,7 +106,9 @@ static const COMMAND_DEFINITION COMMANDS[] =
     { "rangefail", "Causes a range check failure to assert", CmdRangeFail, 0, 0},
     { "bitecookie", "Causes a GS cookie corruption to assert", CmdBiteCookie, 0, 0},
 
-    { "help", "Displays this help menu", _CmdPrintHelp, 0, 0}
+    { "help", "Displays this help menu", _CmdPrintHelp, 0, 0},
+
+    { "readythreads", "Displays this help menu", CmdListThreads2, 0, 0}
 };
 
 #define NO_OF_COMMANDS      ARRAYSIZE(COMMANDS)
diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
index f794c95..4270cbf 100644
--- a/src/HAL9000/src/cmd_thread_helper.c
+++ b/src/HAL9000/src/cmd_thread_helper.c
@@ -16,6 +16,7 @@
 #include "ex_timer.h"
 #include "vmm.h"
 #include "pit.h"
+#include "thread.c"
 
 
 #pragma warning(push)
@@ -72,6 +73,7 @@ _CmdReadAndDumpCpuid(
     );
 
 static FUNC_ListFunction _CmdThreadPrint;
+static FUNC_ListFunction _CmdThreadPrint2;
 
 void
 (__cdecl CmdListCpus)(
@@ -126,9 +128,19 @@ void
     )
 {
     STATUS status;
+    int n = 0;
+    LIST_ENTRY list = m_threadSystemData.AllThreadsList;
 
     ASSERT(NumberOfParameters == 0);
 
+    while (m_threadSystemData.AllThreadsList.Flink != NULL)
+        n++;
+    m_threadSystemData.AllThreadsListCount = n;
+
+    m_threadSystemData.AllThreadsList = list;
+        LOG("store the total number of threads in the system :%5s\n");
+        LOG("\n");
+
     LOG("%7s", "TID|");
     LOG("%20s", "Name|");
     LOG("%5s", "Prio|");
@@ -143,6 +155,29 @@ void
     ASSERT( SUCCEEDED(status));
 }
 
+void
+(__cdecl CmdListThreads2)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    STATUS status;
+
+    ASSERT(NumberOfParameters == 0);
+
+    LOG("%7s", "TID|");
+    LOG("%20s", "Name|");
+    LOG("%5s", "Prio|");
+    LOG("%8s", "State|");
+    LOG("%10s", "Cmp ticks|");
+    LOG("%10s", "Prt ticks|");
+    LOG("%10s", "Ttl ticks|");
+    LOG("%10s", "Process|");
+    LOG("\n");
+
+    status = ThreadExecuteForEachThreadEntry(_CmdThreadPrint2, NULL);
+    ASSERT(SUCCEEDED(status));
+}
+
 void
 (__cdecl CmdYield)(
     IN          QWORD       NumberOfParameters
@@ -698,6 +733,33 @@ STATUS
     return STATUS_SUCCESS;
 }
 
+static
+STATUS
+(__cdecl _CmdThreadPrint2) (
+    IN      PLIST_ENTRY     ListEntry,
+    IN_OPT  PVOID           FunctionContext
+    )
+{
+    PTHREAD pThread;
+
+    ASSERT(NULL != ListEntry);
+    ASSERT(NULL == FunctionContext);
+
+    pThread = CONTAINING_RECORD(ListEntry, THREAD, ReadyList);
+
+    LOG("%6x%c", pThread->Id, '|');
+    LOG("%19s%c", pThread->Name, '|');
+    LOG("%4U%c", pThread->Priority, '|');
+    LOG("%7s%c", _CmdThreadStateToName(pThread->State), '|');
+    LOG("%9U%c", pThread->TickCountCompleted, '|');
+    LOG("%9U%c", pThread->TickCountEarly, '|');
+    LOG("%9U%c", pThread->TickCountCompleted + pThread->TickCountEarly, '|');
+    LOG("%9x%c", pThread->Process->Id, '|');
+    LOG("\n");
+
+    return STATUS_SUCCESS;
+}
+
 static
 void
 _CmdReadAndDumpCpuid(
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index b311f0c..6c00af5 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -31,6 +31,7 @@ typedef struct _THREAD_SYSTEM_DATA
 
     _Guarded_by_(AllThreadsLock)
     LIST_ENTRY          AllThreadsList;
+    int                 AllThreadsListCount;
 
     LOCK                ReadyThreadsLock;
 
@@ -440,11 +441,11 @@ ThreadTick(
     }
     pThread->TickCountCompleted++;
 
-    if (++pCpu->ThreadData.RunningThreadTicks >= THREAD_TIME_SLICE)
+    /*if (++pCpu->ThreadData.RunningThreadTicks >= THREAD_TIME_SLICE)
     {
         LOG_TRACE_THREAD("Will yield on return\n");
         pCpu->ThreadData.YieldOnInterruptReturn = TRUE;
-    }
+    }*/
 }
 
 void
@@ -456,7 +457,7 @@ ThreadYield(
     INTR_STATE oldState;
     PTHREAD pThread = GetCurrentThread();
     PPCPU pCpu;
-    BOOLEAN bForcedYield;
+    //BOOLEAN bForcedYield;
 
     ASSERT( NULL != pThread);
 
@@ -466,8 +467,8 @@ ThreadYield(
 
     ASSERT( NULL != pCpu );
 
-    bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
-    pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
+    /*bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
+    pCpu->ThreadData.YieldOnInterruptReturn = FALSE;*/
 
     if (THREAD_FLAG_FORCE_TERMINATE_PENDING == _InterlockedAnd(&pThread->Flags, MAX_DWORD))
     {
@@ -480,10 +481,10 @@ ThreadYield(
     {
         InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
     }
-    if (!bForcedYield)
-    {
+    //if (!bForcedYield)
+    //{
         pThread->TickCountEarly++;
-    }
+    //}
     pThread->State = ThreadStateReady;
     _ThreadSchedule();
     ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
@@ -574,7 +575,8 @@ ThreadYieldOnInterrupt(
     void
     )
 {
-    return GetCurrentPcpu()->ThreadData.YieldOnInterruptReturn;
+    //return GetCurrentPcpu()->ThreadData.YieldOnInterruptReturn;
+    return TRUE;
 }
 
 void
